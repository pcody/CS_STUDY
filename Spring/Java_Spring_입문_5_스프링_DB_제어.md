

## 스프링 DB 접근 기술

> 자바 스프링 입문 차 인프런 김영한님의 **무료강의**를 보며 정리한 내용입니다.



### H2 데이터베이스 설치

- https://h2database.com/html/main.html

- 윈도우에서 설치하는데 에러 발생 ..

  ![image-20210722135909408](md-images/image-20210722135909408.png)

  

- git bash를 열어서 h2/bin 의 ./h2.sh, ./h2.sh* 명령어 실행했으나 실패

- 이 전에 파일에 권한은 줘야한다. 유저/그룹/기타사용자 111 101 101 RWX (읽기 쓰기 실행)

  ```bash
  kkkstudy@LAPTOP-66BEVBB1 MINGW64 ~/Downloads/h2/bin
  $ chmod 755 h2.sh
  
  kkkstudy@LAPTOP-66BEVBB1 MINGW64 ~/Downloads/h2/bin
  $ ./h2.sh
  Error: Could not find or load main class org.h2.tools.Console
  Caused by: java.lang.ClassNotFoundException: org.h2.tools.Console
  
  kkkstudy@LAPTOP-66BEVBB1 MINGW64 ~/Downloads/h2/bin
  $ ./h2.sh*
  Error: Could not find or load main class org.h2.tools.Console
  Caused by: java.lang.ClassNotFoundException: org.h2.tools.Console
  ```

  

- 구글링 해보니 h2/bin 의 ./h2.bat, ./h2w.bat 으로 실행하길래 해봤더니 정상 동작

  ![image-20210722140330239](md-images/image-20210722140330239.png)

  

- 윈도우의 경우 탐색기 유저 폴더에 test.mv.db 파일이 생성된다.

  ![image-20210722143256910](md-images/image-20210722143256910.png)

  

- 파일로 접근하면 웹콘솔, 앱하고 충돌날 수 있으므로

- 파일에 직접 접근하지 않고 소켓으로 연결 jdbc:h2:tcp://localhost/~/test

  ```sql
  drop table if exists member CASCADE;
  create table member
  (
  id bigint generated by default as identity,
  name varchar(255),
  primary key (id)
  );
  ```



### 순수 JDBC

#### 환경설정

- Java는 기본적으로 DB와 붙이려면 JDBC가 꼭 필요함
- Database client인 h2 client도 필요
- build.gradle 설정

  ```java
  implementation 'org.springframework.boot:spring-boot-starter-jdbc'
  runtimeOnly 'com.h2database:h2'

- src/main/resources/application.properties 설정

  ```java
  spring.datasource.url=jdbc:h2:tcp://localhost/~/test
  spring.datasource.driver-class-name=org.h2.Driver
  spring.datasource.username=sa
  ```

  spring.datasource.username=sa 추가하지 않으면 Wrong user name or pasword 오류가 발생한다...



#### 스프링 설정

- 기존 코드는 건드리지 않고 애플리케이션 설정 코드(assembly code)만 수정하면서 작업할 수 있다는 것이 스프링의 가장 큰 장점이다.

- SpringConfig.java

  ```java
  @Configuration
  public class SpringConfig {
  
      // 리포지토리 Bean을 Jdbc로 바꿔주면서 생성자에 필요한 변수 설정 및 @Autowired설정
      // 스프링에서 설정을 보고 DataSource를 Bean객체로 관리하므로 Autowired해주면 됨
      private final DataSource dataSource;
      @Autowired
      public SpringConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
  //        return new MemoryMemberRepository();
  // 여기를 Jdbc로 바꿔주었다.
          return new JdbcMemberRepository(dataSource);
      }
  }
  ```

- 개방-폐쇄 원칙 (OCP Open-Closed Princple)

  확장에는 열려있고 수정, 변경에는 닫혀있다.

- 스프링의 DI를 사용하여 기존 코드를 수정, 변경하지 않고 설정만으로 구현 클래스를 변경할 수 있다.

- 클래스 관계

  MemberRepository 인터페이스의 메소드들을 구현한 클래스가 MemoryMemberRepository, JdbcMemberRepository이며,
  
  구현체의 의존관계만 바꾸면 사용이 가능하다
  
  ![image-20210722160238339](md-images/image-20210722160238339.png)



- 스프링 컨테이너

  ![image-20210722160628919](md-images/image-20210722160628919.png)



### 통합 테스트

- 통합테스트: 스프링 컨테이너, DB까지 연동하는 테스트

- 단위테스트: 순수한 자바 코드로만 최소한의 단위에서 테스트

- 단위테스트 위주로 진행하도록 훈련하자

- Spring과 함께 테스트를 진행하기 위해 @SpringBootTest annotation을 사용한다. (DB도 포함)

- Transaction을 commit하지 않고 테스트 후 이전 상태로 되돌리기 위해(rollback) @Transactional annotation을 사용한다.

  테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후 항상 롤백하여 다음 테스트에 영향을 주지 않도록 하기 위함 (테스트 각각 적용됨)

  테스트케이스에 Transaction을 썼을 때만 해당 효과 발현

  커밋하려면 @Commit annotation도 있음

- java만 실행하는 테스트를 단위테스트라고 한다.

  ```java
  @SpringBootTest
  // Transactional 사용 안 하면 사용한 데이터가 DB에 남는다
  // Test가 끝난 후 Rollback 하여 변경내용을 DB에 반영하지 않음으로써
  // Test를 반복할 수 있도록 도와준다
  //@Transactional
  class MemberServiceIntegrationTest {
  
  //    MemberService memberService;
  //    MemoryMemberRepository memberRepository;
  //
  //    @BeforeEach
  //    public void beforeEach() {
  //        memberRepository = new MemoryMemberRepository();
  //        memberService = new MemberService(memberRepository);
  //    }
  // 위처럼 직접 객체 생성하는 방법 말고
  // 아래와 같이 스프링으로부터 객체를 받아야한다.
      @Autowired MemberService memberService;
      @Autowired MemberRepository memberRepository;
      // 대충 field injection으로...ㅎㅎ
  
  // 여긴 지우고 Transactional을 사용하면 됨
  //    @AfterEach
  //    public void afterEach() {
  //        memberRepository.clearStore();
  //    }
  
      @Test
      void 회원가입() {
          // given
          // ...
  
          // when
          // ...
  
          // then
          // ...
      }
  
      @Test
      public void 중복_회원_예외() {
          // given
          // ...
  
          // when
          // ...
  
          // then
          // 
      }
  }
  ```

  



### 스프링 Jdbc-Template

- 스프링 JdbcTemplate과 MyBatis같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다.

  SQL은 직접 작성해야한다.

- 디자인 패턴 중 template method pattern을 사용하여 코드를 줄임..

  ```java
  public class JdbcTemplateMemberRepository implements MemberRepository{
  
      private final JdbcTemplate jdbcTemplate;
  
  //    @Autowired
  //    public JdbcTemplateMemberRepository(DataSource dataSource) {
  //        jdbcTemplate = new JdbcTemplate(dataSource);
  //    }
  
      // 생성자 1개면 Autowired 생략 가능
      public JdbcTemplateMemberRepository(DataSource dataSource) {
          jdbcTemplate = new JdbcTemplate(dataSource);
      }
  
      @Override
      public Member save(Member member) {
          // ...
      }
  
      @Override
      public Optional<Member> findById(Long id) {
          // ...
      }
  
      @Override
      public Optional<Member> findByName(String name) {
          // ...
      }
  
      @Override
      public List<Member> findAll() {
          // ...
      }
  
      private RowMapper<Member> memberRowMapper() {
          // ...
      }
  }
  ```

- springconfig

  ```java
  @Configuration
  public class SpringConfig {
  
  // JdbcTemplateMemberRepository 사용
      private DataSource dataSource;
  
      @Autowired
      public SpringConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
          return new JdbcTemplateMemberRepository(dataSource);
      }
  }
  ```

  



### JPA

- SQL 쿼리를 JPA에서 자동으로 처리해줌으로써 개발 생산성을 크게 높여준다.

- JPA를 사용하면 SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임 전환 가능

- build.gradle 설정

  ```java
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  runtimeOnly 'com.h2database:h2'
  ```

- src/main/resources/application.properties 설정

  ```java
  spring.jpa.show-sql=true // jpa가 날리는 sql을 볼 수 있다.
  spring.jpa.hibernate.ddl-auto=none // 객체를 보고 테이블을 만들어주는 기능은 일단 테이블을 다 만들어두었으므로 끈다. none or create
  ```

- JPA는 인터페이스 제공을 하고 구현체로 하이버네이트, 이클립스 등 여러개 벤더를 사용한다.

- ORM(Object Relational Mapping) 객체 관계(DB, 테이블) 매핑

- JPA를 사용하려면 엔티티 매핑을 해야한다.

  ```java
  @Entity
  
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  
  
  import javax.persistence.*;
  
  // persistence의 Entity Annotation을 사용 = JPA 객체임
  @Entity
  public class Member {
  
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      //(DB가 자동 생성해주는 identity 전략)
      private Long id;
  ```

- 리포지토리 EntityManager라는 것으로 엔티티를 관리한다

- build.gradle에서 JPA 라이브러리 설정을 하면 스프링부트에서 자동으로 엔티티매니저를 생성해줌

- 만든 것을 Injection해서 쓰면 됨

  ```java
  public class JpaMemberRepository implements MemberRepository {
  
      private final EntityManager em;
  
      public JpaMemberRepository(EntityManager em) {
          this.em = em;
      }
      
      @Override
      public Member save(Member member) {
          em.persist(member);
          return member;
      }
  
      @Override
      public Optional<Member> findById(Long id) {
          Member member = em.find(Member.class, id);
          return Optional.ofNullable(member);
      }
  
      @Override
      public Optional<Member> findByName(String name) {
          List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                  .setParameter("name", name)
                  .getResultList();
  
          return result.stream().findAny();
      }
  
      @Override
      public List<Member> findAll() {
          return em.createQuery("select m from Member m", Member.class)
                  .getResultList();
          // select * 이 아니고 객체 자체 m을 명시해준다
      }
  }
  ```

- business로직에 @Transactional 표기 해준다.

  ```java
  // JPA사용 시 서비스 계층에 Transactional이 있어야 DB 접근 및 생성, 수정 등이 가능하다
  // 모든 데이터의 변경이 Transaction 안에서 실행되어야함
  @Transactional
  public class MemberService {
  
      private final MemberRepository memberRepository;
  
      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
  ```

- springconfig

  ```java
  @Configuration
  public class SpringConfig {
  
  // JPA사용
      private EntityManager em;
  
      @Autowired
      public SpringConfig(EntityManager em) {
          this.em = em;
      }
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
          return new JpaMemberRepository(em);
      }
  }
  ```

  

### 스프링 데이터 JPA

- 스프링부트, JPA만 사용해도 개발 생산성이 증가하여 개발할 코드가 줄어든다.

- 스프링 데이터 JPA까지 사용하면 기존의 한계를 넘어 리포지토리에 구현 클래스 없이 인터페이스만으로 개발을 완료할 수 있다.

  반복 개발해온 CRUD 기능도 스프링 데이터 JPA가 모두 제공한다.

- JPA를 편리하게 하는 기능이므로 JPA를 먼저 학습한 후에 스프링 데이터 JPA를 학습하도록 한다.

- build.gradle, application.properties -> JPA설정을 그대로 사용한다.

- 스프링 데이터 JPA가 Interface에서 상속받은 (extends JpaRepository<Member, Long>, MemberRepository)를 보고 구현체를 자동으로 만들어서 스프링 빈으로 등록(proxy기술)

  ```java
  public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository{
  
      @Override
      Optional<Member> findByName(String name);
  }
  ```

  ```java
  @Configuration
  public class SpringConfig {
  
  // SpringDataJpa 사용
      private final MemberRepository memberRepository;
  
      // JpaRepository를 상속하고 있는 interface SpringDataJpaMemberRepository를 보고
      // 구현체를 만들어 스프링 빈 등록한다 (자동)
      // SpringConfig의 생성자가 한 개 이므로 Autowired생략 가능하다
      @Autowired
      public SpringConfig(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository);
      }
  }
  ```

  

- 상속관계

  ![image-20210826153314396](md-images/image-20210826153314396.png)

  JpaRepository -> PagingAndSortingRepository -> CrudRepository -> Repository

  JpaRepository를 상속하면 공통 메소드들을 다 사용할 수 있음.

  findAll, save, delete, findOne, 등등등

- 비즈니스 로직에서 Override가 필요한 다른 메소드들마저도 메소드 이름에 따라 JPQL 쿼리문을 만들어주는 규칙이 있다.

  findByName(), findByEmail() 등등

  ```java
  //JPQL : select m from Member m where m.name = ?
  @Override
  Optional<Member> findByName(String name);
  ```

- 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용한다.

  Querydsl 라이브러리로 쿼리를 자바 코드로 안전하게 작성할 수 있으며 동적 쿼리 또한 편리하게 작성 가능하다.

  이 조합으로도 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리, JdbcTemplate을 사용하면 된다.
  
- JPA + SpringDataJPA + Querydsl

- 순수 JDBC, JDBCTemplate, JPA + MyBatis, native SQL도 가능 (다양한 조합이 가능)



### 종합

- 순수Jdbc 

- 스프링 JdbcTemplate : 반복되는 코드가 줄어드나 SQL은 직접 작성

- JPA : 기본적인 CRUD 쿼리 작성할 필요가 없다. 복잡한 쿼리는 Jpql작성 필요.

- 스프링 데이터 JPA : 구현 클래스 작성할 필요가 없이 인터페이스만으로 개발 완료

  

### 기타

- 생성자가 한 개 이면 DI @Autowired 생략 가능

- 윈도우에서 H2 DB 프로세스 죽이기

  1. cmd창 관리자 권한으로 오픈

  2. netstat -ano | findstr 8082

  3. tasklist | findstr 28800

  4. taskkill /f /pid 28800

  ```bash
  C:\WINDOWS\system32>netstat -ano | findstr 8082
    TCP    0.0.0.0:8082           0.0.0.0:0              LISTENING       28800
    TCP    192.192.192.192:3718   192.192.192.192:8082   TIME_WAIT       0
    TCP    192.192.192.192:8082   192.192.192.192:11364  ESTABLISHED     28800
    TCP    192.192.192.192:11364  192.192.192.192:8082   ESTABLISHED     29056
    TCP    [::]:8082              [::]:0                 LISTENING       28800
  
  C:\WINDOWS\system32>tasklist | findstr 28800
  javaw.exe                    28800 Console                   27     93,072 K
  
  C:\WINDOWS\system32>taskkill /f /pid 28800
  성공: 프로세스(PID 28800)가 종료되었습니다.
  ```

- 단축키

  ctrl + alt + n : 인라인으로 바꿔준다.

  ctrl + alt + v : 표현형식을 바꿔준다. (간편 -> 타입 변수명 = 메소드 ~~맞나?~~)

  alt + enter : 람다 형식으로 바꿔준다.

  ctrl + e : 최근에 열어본 파일을 찾을 수 있다.

  ctrl + alt + 방향키 : 최근 열어본 파일 내부 위치?까지의 순서로 이동 하는듯..

- Interface가 Interface를 상속하는 경우 implements가 아닌 extends를 사용한다.
